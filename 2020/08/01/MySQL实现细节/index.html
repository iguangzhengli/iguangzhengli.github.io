<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/favicon16.png?v=2.0.0" type="image/png" sizes="16x16"><link rel="icon" href="/assets/favicon32.png?v=2.0.0" type="image/png" sizes="32x32"><meta name="google-site-verification" content="aAzZPcSXS-6j9fD9Ys-ArQinwI-_EXIrBAEZGVEFyVc"><meta name="description" content="MySQL实现细节                           delete                           删除数据流程       InnoDB 里的数据都是用 B+ 树的结构组织的。ID为主键的聚簇索引。如果我们用 delete 命令把整个表的数据删除呢?结果就是，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。 你现在知道了，de">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL语句执行细节">
<meta property="og:url" content="https://guangzhengli.github.io/2020/08/01/MySQL%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/index.html">
<meta property="og:site_name" content="Ligz&#39;s Blog">
<meta property="og:description" content="MySQL实现细节                           delete                           删除数据流程       InnoDB 里的数据都是用 B+ 树的结构组织的。ID为主键的聚簇索引。如果我们用 delete 命令把整个表的数据删除呢?结果就是，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。 你现在知道了，de">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/guangzhengli/ImgURL@master/uPic/GbuWgz.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/guangzhengli/ImgURL@master/uPic/3P8fGa.png">
<meta property="article:published_time" content="2020-08-01T11:38:20.000Z">
<meta property="article:modified_time" content="2020-12-06T09:25:56.984Z">
<meta property="article:author" content="GuangZheng Li">
<meta property="article:tag" content="database">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/guangzhengli/ImgURL@master/uPic/GbuWgz.png"><meta name="keywords" content="GuangZheng Li, Ligz's Blog"><meta name="description" content=""><title>MySQL语句执行细节 | Ligz's Blog</title><link ref="canonical" href="https://guangzhengli.github.io/2020/08/01/MySQL%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":3},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: {"avoidBanner":true},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Ligz's Blog</div><div class="header-banner-info__subtitle"></div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">MySQL语句执行细节</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-08-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-12-06</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">4.8k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">29分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><h1 id="MySQL实现细节">
          <a href="#MySQL实现细节" class="heading-link"><i class="fas fa-link"></i></a>MySQL实现细节</h1>
      
        <h2 id="delete">
          <a href="#delete" class="heading-link"><i class="fas fa-link"></i></a>delete</h2>
      
        <h3 id="删除数据流程">
          <a href="#删除数据流程" class="heading-link"><i class="fas fa-link"></i></a>删除数据流程</h3>
      <p>InnoDB 里的数据都是用 B+ 树的结构组织的。ID为主键的聚簇索引。如果我们用 delete 命令把整个表的数据删除呢?结果就是，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。</p>
<p>你现在知道了，delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过 delete 命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。</p>
<p>实际上，不止是删除数据会造成空洞，插入数据也会。 如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</p>
<a id="more"></a>


        <h3 id="重建表">
          <a href="#重建表" class="heading-link"><i class="fas fa-link"></i></a>重建表</h3>
      <p>可以使用 alter table A engine=InnoDB 命令来重建表。</p>
<p>MySQL 5.6 版本开始引入的 Online DDL，对这个操作流程做了优化。 我给你简单描述一下引入了 Online DDL 之后，重建表的流程:</p>
<ol>
<li><p>建立一个临时文件，扫描表 A 主键的所有数据页;</p>
</li>
<li><p>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中;</p>
</li>
<li><p>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件(row log)中;</p>
</li>
<li><p>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件;</p>
</li>
<li><p>用临时文件替换表 A 的数据文件。</p>
</li>
</ol>
<p>由于日志文件记录和重放操作这个功能的存在， 这个方案在重建表的过程中，允许对表 A 做增删改操作。这也就是 Online DDL 名字的来源。</p>
<p>对于很大的 表来说，这个操作是很消耗 IO 和 CPU 资源的。因此，如果是线上服务，你要很小心地控制操作时间。如果想要比较安全的操作的话，我推荐你使用 GitHub 开源的 gh-ost 来 做。</p>

        <h2 id="count">
          <a href="#count" class="heading-link"><i class="fas fa-link"></i></a>count(*)</h2>
      <p>在不同的 MySQL 引擎中，count(*) 有不同的实现方式。</p>
<p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高;</p>
<p>而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面 读出来，然后累积计数。</p>
<p>这和 InnoDB 的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是 MVCC 来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于 count(*) 请求来说，InnoDB 只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</p>
<p>你知道的，InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</p>
<p>假设我创建一张表</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `metrics_class`  (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `package_id` bigint(20) NOT NULL,</span><br><span class="line">  `class_name` varchar(255) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  INDEX `idx_package_id` (`package_id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></tbody></table></div></figure>

<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT COUNT(1) FROM metrics_class;</span><br></pre></td></tr></tbody></table></div></figure>

<p>会发现命中了 <code>idx_package_id</code> 这个索引，这是因为这个索引数比主键索引的聚簇索引要小，mysql会遍历这棵树。</p>

        <h3 id="count-count-1-count-id-count-field">
          <a href="#count-count-1-count-id-count-field" class="heading-link"><i class="fas fa-link"></i></a>count(*) count(1) count(id) count(field)</h3>
      <p>对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p>
<p>对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>
<p>单看这两个用法的差别的话，你能对比出来，count(1) 执行得要比 count(主键 id) 快。因 为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</p>
<p>对于 count(字段) 来说:</p>
<ol>
<li><p>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加;</p>
</li>
<li><p>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加</p>
</li>
</ol>
<p>但是 count(<em>) 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。 count(</em>) 肯定不是 null，按行累加。</p>
<p>count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)</p>

        <h2 id="order">
          <a href="#order" class="heading-link"><i class="fas fa-link"></i></a>order</h2>
      <p>创建表</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">`id` int(11) NOT NULL,</span><br><span class="line">`city` varchar(16) NOT NULL,</span><br><span class="line">`name` varchar(16) NOT NULL,</span><br><span class="line">`age` int(11) NOT NULL,</span><br><span class="line">`addr` varchar(128) DEFAULT NULL, </span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">KEY `city` (`city`)</span><br><span class="line">)ENGINE=InnoDB;</span><br></pre></td></tr></tbody></table></div></figure>


        <h3 id="全字段排序">
          <a href="#全字段排序" class="heading-link"><i class="fas fa-link"></i></a>全字段排序</h3>
      <p>查询</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select city,name,age from t where city='杭州' order by name limit 1000 ;</span><br></pre></td></tr></tbody></table></div></figure>

<p>为避免全表扫描，我们需要在 city 字段加 上索引。在 city 字段上创建索引之后，我们用 explain 命令来看看这个语句的执行情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/guangzhengli/ImgURL@master/uPic/GbuWgz.png" alt="GbuWgz"></p>
<p>Extra 这个字段中的“Using filesort”表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。</p>
<p>这个语句执行流程如下所示 :</p>
<ol>
<li><p>初始化 sort_buffer，确定放入 name、city、age 这三个字段;</p>
</li>
<li><p>从索引 city 找到第一个满足 city=’杭州’条件的主键 id，也就是图中的 ID_X;</p>
</li>
<li><p>到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中;</p>
</li>
<li><p>从索引 city 取下一个记录的主键 id;</p>
</li>
<li><p>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的ID_Y;</p>
</li>
<li><p>对 sort_buffer 中的数据按照字段 name 做快速排序;</p>
</li>
<li><p>按照排序结果取前 1000 行返回给客户端。</p>
</li>
</ol>
<p>我们暂且把这个排序过程，称为全字段排序。步骤6中“按 name 排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决 于排序所需的内存和参数 sort_buffer_size。</p>
<p>sort_buffer_size，就是 MySQL 为排序开辟的内存(sort_buffer)的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。 可以这么简单理解，MySQL 将需要排序的数据分成 12 份，每一份单独排序后存在这些临时文件中。然后把这 12 个有序文件再合并成一个有序的大文件。</p>

        <h3 id="rowed-排序">
          <a href="#rowed-排序" class="heading-link"><i class="fas fa-link"></i></a>rowed 排序</h3>
      <p>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在 sort_buffer 和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p>
<p>所以如果单行很大，这个方法效率不够好。那么，如果 MySQL 认为排序的单行长度太大会怎么做呢?</p>
<p><code>SET max_length_for_sort_data = 16;</code></p>
<p>命令表示单行的长度超过这个16，MySQL 就认为单行太大，要换一个算法，即rowid排序。</p>
<p>新的算法放入 sort_buffer 的字段，只有要排序的列(即 name 字段)和主键 id。</p>
<p>但这时，排序的结果就因为少了 city 和 age 字段的值，不能直接返回了，整个执行流程就变成如下所示的样子:</p>
<ol>
<li><p>初始化 sort_buffer，确定放入两个字段，即 name 和 id;</p>
</li>
<li><p>从索引 city 找到第一个满足 city=’杭州’条件的主键 id，也就是图中的 ID_X;</p>
</li>
<li><p>到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中;</p>
</li>
<li><p>从索引 city 取下一个记录的主键 id;</p>
</li>
<li><p>重复步骤 3、4 直到不满足 city=’杭州’条件为止，也就是图中的 ID_Y;</p>
</li>
<li><p>对 sort_buffer 中的数据按照字段 name 进行排序;</p>
</li>
<li><p>遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回。</p>
</li>
</ol>

        <h3 id="优化">
          <a href="#优化" class="heading-link"><i class="fas fa-link"></i></a>优化</h3>
      <p>其实，并不是所有的 order by 语句，都需要排序操作的。从上面分析的执行过程，我们 可以看到，MySQL 之所以需要生成临时表，并且在临时表上做排序操作，其原因是原来的数据都是无序的。</p>
<p>你可以设想下，如果能够保证从 city 这个索引上取出来的行，天然就是按照 name 递增排序的话，是不是就可以不用再排序了呢?</p>
<p>所以，我们可以在这个市民表上创建一个 city 和 name 的联合索引，对应的 SQL 语句 是:</p>
<p><code>alter table t add index city_user(city, name);</code></p>
<p>然后步骤就变为</p>
<ol>
<li><p>从索引 (city,name) 找到第一个满足 city=’杭州’条件的主键 id;</p>
</li>
<li><p>到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回;</p>
</li>
<li><p>从索引 (city,name) 取下一个记录主键 id;</p>
</li>
<li><p>重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’杭州’条件时循环结束。</p>
</li>
</ol>
<p>用explain会发现 Extra 字段中没有了 Using filesort了。不需要排序。这个查询也不用把 4000 行全都读一遍，只要找 到满足条件的前 1000 条记录就可以退出了。也就是说，在我们这个例子里，只需要扫描 1000 次。</p>
<p>如果你还想要优化，不想要回表的话，可以用覆盖索引</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add index city_user_age(city, name, age);</span><br></pre></td></tr></tbody></table></div></figure>

<p>不过这个就要自己去考虑，毕竟索引还是有维护代价的。这是一个需要权衡的决定。</p>

        <h3 id="order-by-range">
          <a href="#order-by-range" class="heading-link"><i class="fas fa-link"></i></a>order by range</h3>
      <p>我在这个表里面插入了 10000 行记录。接下来，我们就一起看看要随机选择 3 个单词，最简单的就是<code>select word from words order by rand() limit 3;</code>这条语句的执行流程是这样的:</p>
<ol>
<li><p>创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段 是 double 类型，为了后面描述方便，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。</p>
</li>
<li><p>从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand()函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word 分别存入临时表的R 和 W 字段中，到此，扫描行数是 10000。</p>
</li>
<li><p>现在临时表有 10000 行数据了，接下来你要在这个没有索引的内存临时表上，按照字段 R 排序。</p>
</li>
<li><p>初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。</p>
</li>
<li><p>从内存临时表中一行一行地取出 R 值和位置信息(我后面会和你解释这里为什么是“位置信息”)，分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000。</p>
</li>
<li><p>在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</p>
</li>
<li><p>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。</p>
</li>
</ol>
<p>接下来，我们通过慢查询日志(slow log)来验证一下我们分析得到的扫描行数是否正确。</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Query_time: 0.900376 Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003</span><br><span class="line">SET timestamp=1541402277;</span><br><span class="line">select word from words order by rand() limit 3;</span><br></pre></td></tr></tbody></table></div></figure>

<p>其中，Rows_examined:20003 就表示这个语句执行过程中扫描了 20003 行，也就验证了我们分析得出的结论。</p>

        <h4 id="优化-1">
          <a href="#优化-1" class="heading-link"><i class="fas fa-link"></i></a>优化</h4>
      <ol>
<li><p>取得整个表的行数，记为 C;</p>
</li>
<li><p>根据相同的随机方法得到 Y1、Y2、Y3; </p>
</li>
<li><p>再执行三个 limit Y, 1 语句得到三行数据。</p>
</li>
</ol>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; select count(*) into @C from t;</span><br><span class="line">2 set @Y1 = floor(@C * rand());</span><br><span class="line">3 set @Y2 = floor(@C * rand());</span><br><span class="line">4 set @Y3 = floor(@C * rand());</span><br><span class="line">5 select * from t limit @Y1，1; // 在应用代码里面取 Y1、Y2、Y3 值，拼出 SQL 后执行</span><br><span class="line">6 select * from t limit @Y2，1;</span><br><span class="line">7 select * from t limit @Y3，1;</span><br></pre></td></tr></tbody></table></div></figure>

<p>MySQL 处理 limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前 Y 个，然后把下一个 记录作为返回结果，因此这一步需要扫描 Y+1 行。再加上，第一步扫描的 C 行，总共需 要扫描 C+Y+1 行，执行代价比随机算法 1 的代价要高。</p>
<p>当然=跟直接 order by rand() 比起来，执行代价还是小很多的。</p>
<p>你可能问了，如果按照这个表有 10000 行来计算的话，C=10000，要是随机到比较大的 Y 值，那扫描行数也跟 20000 差不多了，接近 order by rand() 的扫描行数</p>
<p>取 Y1、Y2 和 Y3 里面最大的一个数，记为 M，最小的一个数记为 N，然后执行下面这条 SQL 语句:</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t limit N, M-N+1;</span><br></pre></td></tr></tbody></table></div></figure>

<p>再加上取整个表总行数的 C 行，这个方案的扫描行数总共只需要 C+M+1 行。</p>
<p>当然也可以先取回 id 值，在应用中确定了三个 id 值以后，再执行三次 where id=X 的语 句也是可以的。</p>

        <h2 id="fun-index">
          <a href="#fun-index" class="heading-link"><i class="fas fa-link"></i></a>fun(index)</h2>
      <p>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能.</p>

        <h3 id="一、条件字段函数操作">
          <a href="#一、条件字段函数操作" class="heading-link"><i class="fas fa-link"></i></a>一、条件字段函数操作</h3>
      <figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tradelog` (</span><br><span class="line">`id` int(11) NOT NULL,</span><br><span class="line">`tradeid` varchar(32) DEFAULT NULL, </span><br><span class="line">`operator` int(11) DEFAULT NULL, </span><br><span class="line">`t_modified` datetime DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">KEY `tradeid` (`tradeid`),</span><br><span class="line">KEY `t_modified` (`t_modified`)</span><br><span class="line">ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></tbody></table></div></figure>

<p>查询7月份的数据</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from tradelog where month(t_modified)=7;</span><br></pre></td></tr></tbody></table></div></figure>

<p>下面是这个 t_modified 索引的示意图。方框上面的数字就是 month() 函数对应的值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/guangzhengli/ImgURL@master/uPic/3P8fGa.png" alt="3P8fGa"></p>
<p>如果你的 SQL 语句条件用的是 where t_modified=’2018-7-1’的话，引擎就会按照上面 绿色箭头的路线，快速定位到 t_modified=’2018-7-1’需要的结果。</p>
<p>实际上，B+ 树提供的这个快速定位能力，来源于同一层兄弟节点的有序性。</p>
<p>但是，如果计算 month() 函数的话，你会看到传入 7 的时候，在树的第一层就不知道该怎 么办了。也就是说，对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</p>
<p>在这个例子里，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引 t_modified，优化器对比索引大小后发现，索引 t_modified 更小，遍历这个索引比遍历 主键索引来得更快。因此最终还是会选择索引 t_modified。</p>

        <h3 id="二、隐式类型转换">
          <a href="#二、隐式类型转换" class="heading-link"><i class="fas fa-link"></i></a>二、隐式类型转换</h3>
      <p>我们一起看一下这条 SQL 语句:</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where tradeid=110717</span><br></pre></td></tr></tbody></table></div></figure>

<p>交易编号 tradeid 这个字段上，本来就有索引，但是 explain 的结果却显示，这条语句需 要走全表扫描。你可能也发现了，tradeid 的字段类型是 varchar(32)，而输入的参数却是整型，所以需要做类型转换</p>
<p>对于优化器来说，这个语句相当于:</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where CAST(tradid AS signed int) = 110717;</span><br></pre></td></tr></tbody></table></div></figure>


        <h3 id="三、隐式字符编码转换">
          <a href="#三、隐式字符编码转换" class="heading-link"><i class="fas fa-link"></i></a>三、隐式字符编码转换</h3>
      <p>两个表的字符集不同，一个是 utf8， 一个是 utf8mb4，做表连接查询的时候用不上关联字段的索引。</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from trade_detail where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value;</span><br></pre></td></tr></tbody></table></div></figure>

<p>CONVERT() 函数，在这里的意思是把输入的字符串转成 utf8mb4 字符集。</p>
<p>这就再次触发了我们上面说到的原则:对索引字段做函数操作，优化器会放弃走树搜索功能。</p>

        <h2 id="Join">
          <a href="#Join" class="heading-link"><i class="fas fa-link"></i></a>Join</h2>
      
        <h2 id="kill">
          <a href="#kill" class="heading-link"><i class="fas fa-link"></i></a>kill</h2>
      <p>kill 并不是马上停止的意思，而是告诉执行线程说，这条语句已经不需要继续 执行了，可以开始“执行停止的逻辑了”。</p>
<p>其实，这跟 Linux 的 kill 命令类似，kill -N pid 并不是让进程直接停止，而 是给进程发一个信号，然后进程处理这个信号，进入终止逻辑。</p>
<p>kill 无效的第一类情况，即:线程没有执行到判断线程状态的逻辑。</p>
<p>另一类情况是，终止逻辑耗时较长。这时候，从 show processlist 结果上看也是 Command=Killed，需要等到终止逻辑完成，语句才算真正完成。</p>

        <h3 id="kill-query-thread-id">
          <a href="#kill-query-thread-id" class="heading-link"><i class="fas fa-link"></i></a>kill query thread_id</h3>
      <p>当用户执行 kill query thread_id_B 时，MySQL 里处理 kill 命令的线程做了两 件事:</p>
<ol>
<li><p>把 session B 的运行状态改成 THD::KILL_QUERY (将变量 killed 赋值为 THD::KILL_QUERY) ;</p>
</li>
<li><p>给 session B 的执行线程发一个信号。</p>
</li>
</ol>
<p>session B 处于锁等待状态，如果只是把 session B 的线程 状态设置 THD::KILL_QUERY，线程 B 并不知道这个状态变化，还是会继续等待。发一个 信号的目的，就是让 session B 退出等待，来处理这个THD::KILL_QUERY 状态。</p>
<p>上面的分析中，隐含了这么三层意思:</p>
<ol>
<li><p>一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态是 THD::KILL_QUERY，才开始进入语句终止逻辑;</p>
</li>
<li><p>如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处;</p>
</li>
<li><p>语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的。</p>
</li>
</ol>

        <h3 id="kill-connection">
          <a href="#kill-connection" class="heading-link"><i class="fas fa-link"></i></a>kill connection</h3>
      <p>而当 session E 执行 kill connection C 命令时，是这么做的，</p>
<ol>
<li><p>把 C 线程状态设置为 KILL_CONNECTION;</p>
</li>
<li><p>关掉 C 线程的网络连接。因为有这个操作，所以你会看到，这时候 session C 收到了断开连接的提示。</p>
</li>
</ol>
<p>但是客户端退出了，这个线程的状态仍然是在等待中。那这个线程什么时候会退出呢?</p>
<p>答案是，只有等到满足进入 InnoDB 的条件后，session C 的查询语句继续执行，然后才有可能判断到线程状态已经变成了 KILL_QUERY 或者 KILL_CONNECTION，再进入终止逻辑阶段。</p>
<blockquote>
<p>参考 《MySQL实战45讲》：<span class="exturl"><a class="exturl__link" href="https://time.geekbang.org/column/intro/100020801" target="_blank" rel="noopener">https://time.geekbang.org/column/intro/100020801</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://guangzhengli.github.io">GuangZheng Li</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://guangzhengli.github.io/2020/08/01/MySQL%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/">https://guangzhengli.github.io/2020/08/01/MySQL%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://guangzhengli.github.io/tags/database/">database</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://guangzhengli.github.io/tags/MySQL/">MySQL</a></span></div><nav class="post-paginator paginator"><div class="paginator-next"><a class="paginator-next__link" href="/2020/08/01/MySQL%E7%B4%A2%E5%BC%95/"><span class="paginator-prev__text">MySQL索引笔记</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="gitalk-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL实现细节"><span class="toc-number">1.</span> <span class="toc-text">
          MySQL实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#delete"><span class="toc-number">1.1.</span> <span class="toc-text">
          delete</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#删除数据流程"><span class="toc-number">1.1.1.</span> <span class="toc-text">
          删除数据流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重建表"><span class="toc-number">1.1.2.</span> <span class="toc-text">
          重建表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#count"><span class="toc-number">1.2.</span> <span class="toc-text">
          count(*)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#count-count-1-count-id-count-field"><span class="toc-number">1.2.1.</span> <span class="toc-text">
          count(*) count(1) count(id) count(field)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#order"><span class="toc-number">1.3.</span> <span class="toc-text">
          order</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全字段排序"><span class="toc-number">1.3.1.</span> <span class="toc-text">
          全字段排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rowed-排序"><span class="toc-number">1.3.2.</span> <span class="toc-text">
          rowed 排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化"><span class="toc-number">1.3.3.</span> <span class="toc-text">
          优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#order-by-range"><span class="toc-number">1.3.4.</span> <span class="toc-text">
          order by range</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fun-index"><span class="toc-number">1.4.</span> <span class="toc-text">
          fun(index)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、条件字段函数操作"><span class="toc-number">1.4.1.</span> <span class="toc-text">
          一、条件字段函数操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、隐式类型转换"><span class="toc-number">1.4.2.</span> <span class="toc-text">
          二、隐式类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、隐式字符编码转换"><span class="toc-number">1.4.3.</span> <span class="toc-text">
          三、隐式字符编码转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Join"><span class="toc-number">1.5.</span> <span class="toc-text">
          Join</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kill"><span class="toc-number">1.6.</span> <span class="toc-text">
          kill</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kill-query-thread-id"><span class="toc-number">1.6.1.</span> <span class="toc-text">
          kill query thread_id</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kill-connection"><span class="toc-number">1.6.2.</span> <span class="toc-text">
          kill connection</span></a></li></ol></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/headimg.jpeg" alt="avatar"></div><p class="sidebar-ov-author__text">阅读和思考，真理与自由</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/esmusssein777" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/esmusssein-81" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a><a class="sidebar-ov-social-item" href="https://space.bilibili.com/379034956" target="_blank" rel="noopener" data-popover="social.bilibili" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Bili</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">8</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">5</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">5</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2018~2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>guangzhengli</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="{&quot;enable&quot;:false,&quot;color&quot;:&quot;0,0,0&quot;,&quot;opacity&quot;:0.6,&quot;count&quot;:99,&quot;zIndex&quot;:-1}" color="0,0,0" opacity="0.6" count="99" zIndex="-1"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js" data-pjax=""></script><script src="https://cdn.jsdelivr.net/npm/js-md5@latest/src/md5.min.js" data-pjax=""></script><script data-pjax="">function loadGitalk () {
  if (!document.getElementById('gitalk-container')) {
    return;
  }

  var gitalk = new Gitalk({
    id: md5(window.location.pathname.slice(1)),
    clientID: '116d9541a4ccef540e18',
    clientSecret: 'c0a9f1545f3bca201c8fe2eeebb10da0a23b10f7',
    repo: 'guangzhengli.github.io',
    owner: 'guangzhengli',
    admin: ['guangzhengli'],
    distractionFreeMode: 'true',
    language: 'zh-CN'
  });
  gitalk.render('gitalk-container');
}

if (true) {
  loadGitalk();
} else {
  window.addEventListener('DOMContentLoaded', loadGitalk, false);
}</script><script src="/js/utils.js?v=2.0.0"></script><script src="/js/stun-boot.js?v=2.0.0"></script><script src="/js/scroll.js?v=2.0.0"></script><script src="/js/header.js?v=2.0.0"></script><script src="/js/sidebar.js?v=2.0.0"></script></body></html>